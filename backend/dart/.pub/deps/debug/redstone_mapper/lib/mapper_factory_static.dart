library redstone_mapper_factory_static;

import 'dart:convert';

import 'package:redstone_mapper/mapper.dart';

/**
 * initialize the mapper system.
 * 
 * This function provides a mapper implementation that
 * uses data generated by the redstone_mapper's transformer,
 * instead of relying on the mirrors API.
 * 
 */ 
void staticBootstrapMapper(Map<Type, TypeInfo> types) {
  _staticTypeInfo = types;

  configure(_getOrCreateMapper, _createValidator);
}

typedef dynamic StaticDecoder(Object data, 
                              StaticMapperFactory factory, 
                              FieldDecoder fieldDecoder,
                              Map<Type, Codec> typeCodecs);

typedef dynamic StaticEncoder(Object obj, 
                              StaticMapperFactory factory, 
                              FieldEncoder fieldEncoder,
                              Map<Type, Codec> typeCodecs);

typedef dynamic StaticMapperFactory(Type type, {bool encodable, bool isList, bool isMap});

typedef dynamic StaticFieldGetter(Object obj);

class TypeInfo {
  
  final StaticEncoder encoder;
  final StaticDecoder decoder;
  final Map<String, FieldWrapper> fields;
  
  TypeInfo(this.encoder, this.decoder, this.fields);
  
}

class FieldWrapper {
  
  List metadata;
  StaticFieldGetter getter;
  
  FieldWrapper(this.getter, [this.metadata = const [const Field()]]);
  
}

Map<Type, TypeInfo> _staticTypeInfo = const {};
Map<Type, _StaticMapper> _cache = {
  String: const _StaticMapper.notEncodable(),
  int: const _StaticMapper.notEncodable(),
  double: const _StaticMapper.notEncodable(),
  num: const _StaticMapper.notEncodable(),
  bool: const _StaticMapper.notEncodable(),
  Object: const _StaticMapper.notEncodable(),
  Null: const _StaticMapper.notEncodable()
};

class _StaticMapper implements Mapper {
  
  final MapperDecoder decoder;
  final MapperEncoder encoder;
  final Map<String, FieldWrapper> _fields;
  
  _StaticMapper(this.decoder, this.encoder, this._fields);
  
  _StaticMapper.list([_StaticMapper wrap]) :
    decoder = new _ListDecoder(wrap),
    encoder = new _ListEncoder(wrap),
    _fields = const {};
    
  _StaticMapper.map([_StaticMapper wrap]) :
    decoder = new _MapDecoder(wrap),
    encoder = new _MapEncoder(wrap),
    _fields = const {};
  
  const _StaticMapper.notEncodable() :
    decoder = const _DefaultDecoder(),
    encoder = const _DefaultEncoder(),
    _fields = const {};
  
}

class _DefaultDecoder {

  const _DefaultDecoder();
  
  call(Object data, FieldDecoder fieldDecoder, 
       Map<Type, Codec> typeCodecs, [Type type]) {
    return data;
  }

}

class _DefaultEncoder {

  const _DefaultEncoder();
  
  call(Object obj, FieldEncoder fieldEncoder, Map<Type, Codec> typeCodecs) {
    return obj;
  }

}

class _MapDecoder {
  
  final _StaticMapper wrappedMapper;
  
  _MapDecoder([this.wrappedMapper]);
  
  call(Object data, FieldDecoder fieldDecoder, 
       Map<Type, Codec> typeCodecs, [Type type]) {
    if (data is! Map) {
      throw new MapperException("Expecting Map, found ${data.runtimeType}");
    }
    
    var decoded = {};
    (data as Map).forEach((key, value) {
      var mapper = wrappedMapper;
      if (mapper == null) {
        mapper = _getOrCreateMapper(type);
      }
      decoded[key] = mapper.decoder(value, fieldDecoder, typeCodecs);
    });
    return decoded;
  }
  
}

class _MapEncoder {
  
  final _StaticMapper wrappedMapper;
  
  _MapEncoder([this.wrappedMapper]);
  
  call(Object data, FieldEncoder fieldEncoder, Map<Type, Codec> typeCodecs) {
    if (data is Map) {
      var encoded = {};
      var mapper = wrappedMapper;
      if (mapper == null) {
        mapper = _getOrCreateMapper(data.runtimeType);
      }
      data.forEach((key, value) {
        encoded[key] = mapper.encoder(value, fieldEncoder, typeCodecs);
      });
      return encoded;
    }
    return data;
  }
  
}

class _ListDecoder {
  
  final _StaticMapper wrappedMapper;
  
  _ListDecoder([this.wrappedMapper]);
  
  call(Object data, FieldDecoder fieldDecoder, 
       Map<Type, Codec> typeCodecs, [Type type]) {
    if (data is! List) {
      throw new MapperException("Expecting List, found ${data.runtimeType}");
    }
    
    var mapper = wrappedMapper;
    if (mapper == null) {
      mapper = _getOrCreateMapper(type);
    }
    return new List.from((data as List).map((value) =>
      mapper.decoder(value, fieldDecoder, typeCodecs)));
  }
  
}

class _ListEncoder {
  
  final _StaticMapper wrappedMapper;
  
  _ListEncoder([this.wrappedMapper]);
  
  call(Object data, FieldEncoder fieldEncoder, Map<Type, Codec> typeCodecs) {
    if (data is List) {
      return new List.from(data.map((value) {
        var mapper = wrappedMapper;
        if (mapper == null) {
          mapper = _getOrCreateMapper(value.runtimeType);
        }
        return mapper.encoder(value, fieldEncoder, typeCodecs);
      }));
    }
    return data;
  }
  
}

_StaticMapper _getOrCreateMapper(Type type, 
                                 {bool encodable: true, 
                                  bool isList: false, 
                                  bool isMap: false,
                                  _StaticMapper wrap}) {
  
  if (!encodable) {
    return const _StaticMapper.notEncodable();
  } else if (isList) {
    return new _StaticMapper.list(wrap);
  } else if (isMap) {
    return new _StaticMapper.map(wrap);
  } else {
    var mapper = _cache[type];
    if (mapper == null) {
      var typeInfo = _staticTypeInfo[type];
      if (typeInfo != null) {
        
        var decoder = (data, fieldDecoder, typeCodecs, [fieldType]) {
          if (data == null) {
            return data;
          }
          if (data is List) {
            return new _StaticMapper.list().decoder(data, fieldDecoder, 
                typeCodecs, type);
          }
          
          try {
            return typeInfo.decoder(data, _getOrCreateMapper, fieldDecoder, typeCodecs);
          } catch(e) {
            throw new MapperException("Failed to decode: $data \nreason: $e");
          }
        };
        
        var encoder = (obj, fieldEncoder, typeCodecs) {
          if (obj == null) {
            return null;
          }
          try {
            return typeInfo.encoder(obj, _getOrCreateMapper, fieldEncoder, typeCodecs);
          } catch(e) {
            throw new MapperException("Can't encode $obj: $e");
          }
        };
        
        mapper = new _StaticMapper(decoder, encoder, typeInfo.fields);
      } else {
        throw new MapperException("UnsupportedType: $type. "
          "This type wasn't mapped by redstone_mapper's transformer. See http://goo.gl/YYMou2 for more information.");
      }
      _cache[type] = mapper;
    }
    return mapper;
  }
}

class _StaticValidator implements Validator {
  
  final Type _type;
    
  Map<String, FieldWrapper> _fields;
  Map<String, List<ValidationRule>> _rules = {};
  
  _StaticValidator([Type this._type]) {
    if (_type != null) {
      _fields = _getOrCreateMapper(_type)._fields;
    }
  }
  
  @override
  addAll(Validator validator) {
    (validator as _StaticValidator)._rules.forEach((fieldName, rules) {
      rules.forEach((r) => add(fieldName, r));
    });
  }

  @override
  add(String field, ValidationRule rule) {
    if (_fields != null && !_fields.containsKey(field)) {
      throw new ValidationException("$_type has no field '$field'");
    }
    var fieldRules = _rules[field];
    if (fieldRules == null) {
      fieldRules = [];
      _rules[field] = fieldRules;
    }
    fieldRules.add(rule);
  }

  @override
  ValidationError execute(Object obj) {
    if (obj is Map) {
      return _validateMap(obj);
    } else {
      if (_type == null) {
        throw new ArgumentError("This validator can only validate maps");
      }
      return _validateObj(obj);
    }    
  }
  
  ValidationError _validateObj(obj) {
        
    var invalidFields = {};
    _rules.forEach((field, rules) {
      rules.forEach((rule) {
        if (!rule.validate(_fields[field].getter(obj))) {
          List errors = invalidFields[field];
          if (errors == null) {
            errors = [];
            invalidFields[field] = errors;
          }
          errors.add(rule.type);
        }
      });
    });
    
    if (invalidFields.isNotEmpty) {
      return new ValidationError(invalidFields);
    }
    
    return null;
  }
  
  ValidationError _validateMap(Map map) {
    var invalidFields = {};
    
    _rules.forEach((field, rules) {
      rules.forEach((rule) {
        if (!rule.validate(map[field])) {
          List errors = invalidFields[field];
          if (errors == null) {
            errors = [];
            invalidFields[field] = errors;
          }
          errors.add(rule.type);
        }
      });
    });
    
    if (invalidFields.isNotEmpty) {
      return new ValidationError(invalidFields);
    }
    
    return null;
  }
  
}

_StaticValidator _createValidator([Type type, bool parseAnnotations = false]) {
  var validator = new _StaticValidator(type);
  if (parseAnnotations) {
    validator._fields.forEach((fieldName, fieldData) {
      fieldData.metadata.where((m) => m is ValidationRule).forEach((r) =>
          validator.add(fieldName, r));
    });
  }
  return validator;
}