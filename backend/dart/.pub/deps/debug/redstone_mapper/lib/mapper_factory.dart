library redstone_mapper_factory;

import 'dart:convert';
import 'dart:mirrors';

import 'package:redstone_mapper/mapper.dart';

/**
 * Initialize the mapper system.
 * 
 * It's necessary to call this method before encoding or decoding
 * any object. When using redstone_mapper on the client side, it's
 * necessary to call this method from the `main()` function, so during
 * `pub build`, it can be replaced by `staticBootstrapMapper()`, which uses
 * static data generated by the redstone_mapper's tranformer to encode and
 * decode objects.
 * 
 *      main() {
 *        ...
 *        bootstrapMapper();
 *        ...
 *      }
 * 
 * Also, be sure to set the redstone_mapper's transformer in your
 * `pubspec.yaml` file.
 * 
 * On the server side, if you are using redstone_mapper as a
 * Redstone.dart plugin, then this function will be called for
 * you.
 */ 
void bootstrapMapper() {
  configure(_getOrCreateMapper, _createValidator);
}


class _DynamicMapper implements Mapper {
  
  final MapperDecoder decoder;
  final MapperEncoder encoder;
  
  final Map<String, _FieldData> _fields;
  
  final bool isCollection;
  
  bool get isEncodable => _fields.isNotEmpty;
  
  _DynamicMapper(this.decoder, this.encoder, this._fields) : 
      isCollection = false;
  
  const _DynamicMapper.notEncodable() :
    decoder = const _DefaultDecoder(),
    encoder = const _DefaultEncoder(),
    _fields = const {},
    isCollection = false;
    
  const _DynamicMapper.map() :
    decoder = const _MapDecoder(),
    encoder = const _MapEncoder(),
    _fields = const {},
    isCollection = true;
    
  const _DynamicMapper.list() :
      decoder = const _ListDecoder(),
      encoder = const _ListEncoder(),
      _fields = const {},
      isCollection = true;
}

class _FieldData {
  
  final Symbol symbol;
  final List metadata;
  
  _FieldData(this.symbol, this.metadata);
  
}

class _DynamicValidator implements Validator {
  
  final Type _type;
    
  Map<String, _FieldData> _fields;
  Map<String, List<ValidationRule>> _rules = {};
  
  _DynamicValidator([Type this._type]) {
    if (_type != null) {
      _fields = _getOrCreateMapper(_type)._fields;
    }
  }
  
  @override
  addAll(Validator validator) {
    (validator as _DynamicValidator)._rules.forEach((fieldName, rules) {
      rules.forEach((r) => add(fieldName, r));
    });
  }

  @override
  add(String field, ValidationRule rule) {
    if (_fields != null && !_fields.containsKey(field)) {
      throw new ValidationException("$_type has no field '$field'");
    }
    var fieldRules = _rules[field];
    if (fieldRules == null) {
      fieldRules = [];
      _rules[field] = fieldRules;
    }
    fieldRules.add(rule);
  }

  @override
  ValidationError execute(Object obj) {
    if (obj is Map) {
      return _validateMap(obj);
    } else {
      if (_type == null) {
        throw new ArgumentError("This validator can only validate maps");
      }
      return _validateObj(obj);
    }    
  }
  
  ValidationError _validateObj(obj) {
    var mirror = reflect(obj);
        
    var invalidFields = {};
    _rules.forEach((field, rules) {
      rules.forEach((rule) {
        if (!rule.validate(mirror.getField(_fields[field].symbol).reflectee)) {
          List errors = invalidFields[field];
          if (errors == null) {
            errors = [];
            invalidFields[field] = errors;
          }
          errors.add(rule.type);
        }
      });
    });
    
    if (invalidFields.isNotEmpty) {
      return new ValidationError(invalidFields);
    }
    
    return null;
  }
  
  ValidationError _validateMap(Map map) {
    var invalidFields = {};
    
    _rules.forEach((field, rules) {
      rules.forEach((rule) {
        if (!rule.validate(map[field])) {
          List errors = invalidFields[field];
          if (errors == null) {
            errors = [];
            invalidFields[field] = errors;
          }
          errors.add(rule.type);
        }
      });
    });
    
    if (invalidFields.isNotEmpty) {
      return new ValidationError(invalidFields);
    }
    
    return null;
  }
  
}

final Map<Type, _DynamicMapper> _cache = {
  String: const _DynamicMapper.notEncodable(),
  int: const _DynamicMapper.notEncodable(),
  double: const _DynamicMapper.notEncodable(),
  num: const _DynamicMapper.notEncodable(),
  bool: const _DynamicMapper.notEncodable(),
  Object: const _DynamicMapper.notEncodable(),
  Null: const _DynamicMapper.notEncodable()
};

class _DefaultDecoder {

  const _DefaultDecoder();
  
  call(Object data, FieldDecoder fieldDecoder, 
       Map<Type, Codec> typeCodecs, [Type type]) {
    return data;
  }

}

class _DefaultEncoder {

  const _DefaultEncoder();
  
  call(Object obj, FieldEncoder fieldEncoder, 
       Map<Type, Codec> typeCodecs) {
    return obj;
  }

}

class _MapDecoder {
  
  const _MapDecoder();
  
  call(Object data, FieldDecoder fieldDecoder, 
       Map<Type, Codec> typeCodecs, [Type type]) {
    if (data is! Map) {
      throw new MapperException("Expecting ${type}, found ${data.runtimeType}");
    }
    
    TypeMirror clazz = reflectType(type);
    if (clazz.isOriginalDeclaration) {
      return data;
    }
    
    var decoded = {};
    var valueType = clazz.typeArguments[1].reflectedType;
    var mapper = _getOrCreateMapper(valueType);
    (data as Map).forEach((key, value) {
      decoded[key] = mapper.decoder(value, fieldDecoder, 
          typeCodecs, valueType);
    });
    return decoded;
  }
  
}

class _MapEncoder {
  
  const _MapEncoder();
  
  call(Object data, FieldEncoder fieldEncoder, 
       Map<Type, Codec> typeCodecs) {
    if (data is Map) {
      var encoded = {};
      data.forEach((key, value) {
        var mapper = _getOrCreateMapper(value.runtimeType);
        encoded[key] = mapper.encoder(value, fieldEncoder, typeCodecs);
      });
      return encoded;
    }
    return data;
  }
  
}

class _ListDecoder {
  
  const _ListDecoder();
  
  call(Object data, FieldDecoder fieldDecoder, 
       Map<Type, Codec> typeCodecs, [Type type]) {
    TypeMirror clazz = reflectType(type);
    if (data is! List) {
      if (clazz.isOriginalDeclaration) {
        throw new MapperException("Expecting List<${type}>, found ${data.runtimeType}");
      } else {
        throw new MapperException("Expecting ${type}, found ${data.runtimeType}");
      }
    }
    
    var valueType;
    if (!clazz.isOriginalDeclaration) {
      valueType = clazz.typeArguments[0].reflectedType;
    } else {
      if (clazz.isSubtypeOf(_listMirror)) {
        return const _DynamicMapper.notEncodable().decoder(data, 
            fieldDecoder, typeCodecs);
      }
      valueType = type;
    }
    
    var mapper = _getOrCreateMapper(valueType);
    return new List.from((data as List).map((value) =>
      mapper.decoder(value, fieldDecoder, typeCodecs, valueType)));
  }
  
}

class _ListEncoder {
  
  const _ListEncoder();
  
  call(Object data, FieldEncoder fieldEncoder, Map<Type, Codec> typeCodecs) {
    if (data is List) {
      return new List.from(data.map((value) {
        var mapper = _getOrCreateMapper(value.runtimeType);
        return mapper.encoder(value, fieldEncoder, typeCodecs);
      }));
    }
    return data;
  }
  
}

final _mapMirror = reflectClass(Map);
final _listMirror = reflectClass(List);

_DynamicMapper _getOrCreateMapper(Type type) {
  var mapper = _cache[type];
  if (mapper == null) {
    var clazz = reflectClass(type);
    bool isMap = clazz == _mapMirror || clazz.isSubclassOf(_mapMirror);
    bool isList = clazz == _listMirror || clazz.isSubclassOf(_listMirror);
    if (!isMap && !isList) {
      clazz.superinterfaces.forEach((i) {
        var d = i.originalDeclaration;
        if (d == _mapMirror) {
          isMap = true;
        } else if (d == _listMirror) {
          isList = true;
        }
      });
    }
    
    
    if (isMap) {
      mapper = const _DynamicMapper.map();
      _cache[type] = mapper;
      return mapper;
    } else if(isList) {
      mapper = const _DynamicMapper.list();
      _cache[type] = mapper;
      return mapper;
    }
    
    var decodeChain = [];
    var encodeChain = [];
    var fields = {};
    
    _buildChain(clazz, decodeChain, encodeChain, fields);
  
    if (fields.isEmpty) {
      
      mapper = const _DynamicMapper.notEncodable();
      
    } else {
    
      var decoder = (data, fieldDecoder, typeCodecs, [fieldType]) {
        if (data == null) {
          return null;
        }
        if (data is List) {
          return const _DynamicMapper.list().decoder(data, fieldDecoder, 
              typeCodecs, type);
        }
        var mirror;
        try {
          mirror = clazz.newInstance(const Symbol(""), const []);
        } catch(e) {
          throw new MapperException(
              "Can't create an instance of $type. Does $type have a default constructor? Cause: $e")
              ..append(new StackElement(true, type.toString()));
        }
        
        try {
          decodeChain.forEach((f) => f(data, mirror, fieldDecoder, typeCodecs));
        } on MapperException catch(e) {
          throw e..append(new StackElement(true, type.toString()));
        } catch(e) {
          throw new MapperException("Can't decode $type: $e")
            ..append(new StackElement(true, type.toString()));
        }
        return mirror.reflectee;
      };
      var encoder = (obj, fieldEncoder, typeCodecs) {
        if (obj == null) {
          return null;
        }
        var data = {};
        try {
          var mirror = reflect(obj);
          encodeChain.forEach((f) => f(data, mirror, fieldEncoder, typeCodecs));
        } on MapperException catch(e) {
          throw e..append(new StackElement(true, type.toString()));
        } catch(e) {
          throw new MapperException("Can't encode $obj: $e")
            ..append(new StackElement(true, type.toString()));
        }
        return data;
      };
      
      mapper = new _DynamicMapper(decoder, encoder, fields);
    
    }
    _cache[type] = mapper;
  }
  return mapper;
}

void _buildChain(ClassMirror clazz, List decodeChain, 
                 List encodeChain, Map<String, _FieldData> fields,
                 [Map<String, _ChainIdx> fieldIdxs]) {

  if (fieldIdxs == null) {
    fieldIdxs = {};
  }
  
  if(clazz.superclass != null && clazz.superclass.reflectedType != Object) {
    _buildChain(clazz.superclass, decodeChain, encodeChain, fields, fieldIdxs);
  }
  
  clazz.superinterfaces.forEach((interface) =>
      _buildChain(interface, decodeChain, encodeChain, fields, fieldIdxs));
  
  clazz.declarations.forEach((name, mirror) {
    
    if (mirror is VariableMirror && !mirror.isStatic && !mirror.isPrivate) {
      
      var metadata = mirror.metadata.map((m) => m.reflectee).toList(growable: false);
      var fieldInfo = metadata.
          firstWhere((o) => o is Field, orElse: () => null) as Field;
      
      if (fieldInfo != null) {
         
        var fieldName = MirrorSystem.getName(mirror.simpleName);
        fields[fieldName] = new _FieldData(mirror.simpleName, metadata);

        var chainIdx = fieldIdxs[fieldName];
        if (chainIdx == null) {
          chainIdx = new _ChainIdx();
          fieldIdxs[fieldName] = chainIdx;
        }

        if (chainIdx.encodeIdx != null) {
          encodeChain.removeAt(chainIdx.encodeIdx);
        }
        
        _encodeField(fieldName, fieldInfo, metadata,
            encodeChain, mirror, mirror.type);

        chainIdx.encodeIdx = encodeChain.length - 1;
        
        if (!mirror.isFinal) {

          if (chainIdx.decodeIdx != null) {
            decodeChain.removeAt(chainIdx.decodeIdx);
          }

          _decodeField(fieldName, fieldInfo, metadata, 
              decodeChain, mirror, mirror.type);

          chainIdx.decodeIdx = decodeChain.length - 1;

        }
          
      }
      
    } else if (mirror is MethodMirror && 
               !mirror.isStatic && !mirror.isPrivate) {
      
      var metadata = mirror.metadata.map((m) => m.reflectee).toList(growable: false);
      var fieldInfo = metadata.
          firstWhere((o) => o is Field, orElse: () => null) as Field;
      
      if (fieldInfo != null) {

        var fieldName = MirrorSystem.getName(mirror.simpleName);
        if (mirror.isGetter) {
          fields[fieldName] = new _FieldData(mirror.simpleName, metadata);

          var chainIdx = fieldIdxs[fieldName];
          if (chainIdx == null) {
            chainIdx = new _ChainIdx();
            fieldIdxs[fieldName] = chainIdx;
          }

          if (chainIdx.encodeIdx != null) {
            encodeChain.removeAt(chainIdx.encodeIdx);
          }

          TypeMirror fieldType = mirror.returnType;
          _encodeField(fieldName, fieldInfo, metadata,
              encodeChain, mirror, fieldType);

          chainIdx.encodeIdx = encodeChain.length - 1;

        } else if (mirror.isSetter) {
          fieldName = fieldName.substring(0, fieldName.length - 1);

          var chainIdx = fieldIdxs[fieldName];
          if (chainIdx == null) {
            chainIdx = new _ChainIdx();
            fieldIdxs[fieldName] = chainIdx;
          }

          if (chainIdx.decodeIdx != null) {
            decodeChain.removeAt(chainIdx.decodeIdx);
          }

          TypeMirror fieldType = mirror.parameters[0].type;
          _decodeField(fieldName, fieldInfo, metadata, 
              decodeChain, mirror, fieldType);

          chainIdx.decodeIdx = decodeChain.length - 1;

        }
      }
      
    }
    
  });
}

void _decodeField(String fieldName, Field fieldInfo, List metadata, 
                  List decodeChain, DeclarationMirror mirror, TypeMirror fieldType) {
  
  var type = fieldType.reflectedType;
  var name = new Symbol(fieldName);
  
  decodeChain.add((data, InstanceMirror obj, FieldDecoder fieldDecoder, 
                   Map<Type, Codec> typeCodecs) {
    _DynamicMapper mapper = _getOrCreateMapper(type);
    try {
      var value = fieldDecoder(data, fieldName, fieldInfo, metadata);
      if (value != null) {
        var typeCodec = typeCodecs[type];
        if (typeCodec != null) {
          value = typeCodec.decode(value);
        }
        value = mapper.decoder(value, fieldDecoder, typeCodecs, type);
        obj.setField(name, value);
      }
    } on MapperException catch(e) {
      throw e..append(new StackElement(false, fieldName));
    } catch(e) {
      throw new MapperException("$e")..append(new StackElement(false, fieldName));
    }
  });
  
}

void _encodeField(String fieldName, Field fieldInfo, List metadata,
                  List encodeChain, DeclarationMirror mirror, TypeMirror fieldType) {

  var type = fieldType.reflectedType;
  encodeChain.add((Map data, InstanceMirror obj, FieldEncoder fieldEncoder, 
                   Map<Type, Codec> typeCodecs) {
    var value = obj.getField(mirror.simpleName).reflectee;
    if (value != null) {
      var mapper = _getOrCreateMapper(type);
      value = mapper.encoder(value, fieldEncoder, typeCodecs);
    
      var typeCodec = typeCodecs[type];
      value = typeCodec != null ? typeCodec.encode(value) : value;
    }
    
    try {
      fieldEncoder(data, fieldName, fieldInfo, metadata, value);
    } on MapperException catch(e) {
      throw e..append(new StackElement(false, fieldName));
    } catch(e) {
      throw new MapperException("$e")..append(new StackElement(false, fieldName));
    }
  });
  
}

_DynamicValidator _createValidator([Type type, bool parseAnnotations = false]) {
  var validator = new _DynamicValidator(type);
  if (parseAnnotations) {
    validator._fields.forEach((fieldName, fieldData) {
      fieldData.metadata.where((m) => m is ValidationRule).forEach((r) =>
          validator.add(fieldName, r));
    });
  }
  return validator;
}

class _ChainIdx {

  int decodeIdx;
  int encodeIdx;

}

